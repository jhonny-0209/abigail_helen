<!doctype html>
<html lang=es>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Galaxia del Amor</title>
<style>
  body,
  html {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
  }

  canvas {
    display: block;
  }

  .player {
    position: fixed;
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    width: 90%;
    max-width: 600px;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border: 2px solid #f60;
    border-radius: 999px;
    background: 0 0;
    box-shadow: 0 0 15px #f60, 0 0 30px #f30;
    z-index: 1000;
    font-family: Arial, sans-serif;
    color: #fff;
    font-size: 14px;
  }

  .player button {
    background: 0 0;
    border: none;
    color: #fff;
    font-size: 22px;
    cursor: pointer;
    filter: drop-shadow(0 0 6px #ff6600);
    transition: transform .2s;
  }

  .player button:hover {
    transform: scale(1.2);
    filter: drop-shadow(0 0 10px #ff3300);
  }

  .progress {
    flex-grow: 1;
    height: 14px;
    background: rgba(255, 255, 255, .12);
    border-radius: 999px;
    overflow: hidden;
    cursor: pointer;
    position: relative;
  }

  .progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(
      270deg,
      #f60,
      #f30,
      #f09,
      #f60
    );
    background-size: 400% 400%;
    border-radius: 999px;
    box-shadow: 0 0 10px #f60;
    animation: flowing 6s ease infinite;
  }

  @keyframes flowing {
    0% {
      background-position: 0 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0 50%;
    }
  }

  .time {
    min-width: 74px;
    text-align: right;
    font-size: 12px;
    color: #fff;
    text-shadow: 0 0 5px #f60;
  }
  #blackholeBtn {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 100px;          /* tama√±o del agujero */
  height: 100px;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  background: transparent;
  border: none;
  cursor: pointer;
  z-index: 500;
}

/* efecto al pasar el mouse (opcional) */
#blackholeBtn:hover {
  box-shadow: 0 0 25px rgba(255, 80, 120, 0.4);
}

</style>

</head>
<body>
  <button id="blackholeBtn"></button>
<canvas id=c></canvas>
<div class=player>
<button id=play>‚ñ∂Ô∏è</button>
<div class=progress id=progress><div class=progress-bar id=progress-bar></div></div>
<div class=time id=time>0:00 / 0:00</div>
</div>
<audio id=audio loop>
<source src="albun_2026/musica/galaxia.mp3" type=audio/mpeg>
</audio>
<script src=https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js></script>
<script>
  const audio = document.getElementById("audio");
  const playBtn = document.getElementById("play");
  const progress = document.getElementById("progress");
  const progressBar = document.getElementById("progress-bar");
  const timeDisplay = document.getElementById("time");

  let isPlaying = false;

  function formatTime(t) {
    if (!isFinite(t)) return "0:00";
    return (
      Math.floor(t / 60) +
      ":" +
      Math.floor(t % 60).toString().padStart(2, "0")
    );
  }

  playBtn.addEventListener("click", async () => {
    if (isPlaying) {
      audio.pause();
      playBtn.textContent = "‚ñ∂Ô∏è";
    } else {
      await audio.play();
      playBtn.textContent = "‚è∏Ô∏è";
    }
    isPlaying = !isPlaying;
  });
    

  audio.addEventListener("timeupdate", () => {
    const percent = (audio.currentTime / audio.duration) * 100;
    progressBar.style.width = (isFinite(percent) ? percent : 0) + "%";
    timeDisplay.textContent =
      formatTime(audio.currentTime) +
      " / " +
      formatTime(audio.duration);
  });

  progress.addEventListener("click", e => {
    const rect = progress.getBoundingClientRect();
    const ratio = (e.clientX - rect.left) / rect.width;
    if (isFinite(audio.duration)) {
      audio.currentTime = ratio * audio.duration;
    }
  });

  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true
  });

  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(innerWidth, innerHeight);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    60,
    innerWidth / innerHeight,
    0.1,
    5000
  );

  let targetDist = 300;
  let currentDist = 300;
  let rotX = 0.2;
  let rotY = 0;

  const loader = new THREE.TextureLoader();
  const nebulaTex = loader.load(
    "https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/cube/space/px.jpg"
  );
  scene.background = nebulaTex;
    const centerImageTexture = loader.load("albun_2026/musica/GALAXIA.jpeg");
    const centerImageMaterial = new THREE.SpriteMaterial({
        map: centerImageTexture,
        transparent: false,
        opacity: 10
        });

    const centerImage = new THREE.Sprite(centerImageMaterial);
    centerImage.position.set(0, 0, 0);
    centerImage.scale.set(120, 109, 1);
    centerImageMaterial.depthWrite = false;
    scene.add(centerImage);

  (function (stars = 2000, radius = 3000) {
    const geo = new THREE.BufferGeometry();
    const arr = new Float32Array(stars * 3);

    for (let i = 0; i < stars; i++) {
      const r = radius * (0.3 + 0.7 * Math.random());
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);

      arr[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      arr[i * 3 + 1] = r * Math.cos(phi);
      arr[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    }

    geo.setAttribute("position", new THREE.BufferAttribute(arr, 3));

    scene.add(
      new THREE.Points(
        geo,
        new THREE.PointsMaterial({
          size: 1.5,
          color: 0xffffff,
          depthWrite: false
        })
      )
    );
  })();

  const coreMat = new THREE.MeshPhongMaterial({
    color: 0x111111,
    transparent: true,
    opacity: 0.6,
    shininess: 200
  });

  const core = new THREE.Mesh(
    new THREE.SphereGeometry(55, 64, 64),
    coreMat
  );
  scene.add(core);

  function makeCenterTextTexture(text) {
    const c = document.createElement("canvas");
    c.width = 512;
    c.height = 512;
    const ctx = c.getContext("2d");

    ctx.clearRect(0, 0, c.width, c.height);
    ctx.font = "bold 80px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#ff0033";
    ctx.shadowColor = "#ff66aa";
    ctx.shadowBlur = 50;
    ctx.fillText(text, c.width / 2, c.height / 2);

    return new THREE.CanvasTexture(c);
  }

  const centerTex = makeCenterTextTexture("TE AMO ‚ù§Ô∏è");
  const centerMat = new THREE.SpriteMaterial({
    map: centerTex,
    transparent: true
  });

  const centerSprite = new THREE.Sprite(centerMat);
  centerSprite.scale.set(60, 60, 1);
  centerSprite.position.set(0, 0, 0);
  centerSprite.renderOrder = 999;
  scene.add(centerSprite);

  function makeGlow(size = 768, c1 = "255,160,0", c2 = "255,60,0") {
    const c = document.createElement("canvas");
    c.width = c.height = size;
    const ctx = c.getContext("2d");

    const g = ctx.createRadialGradient(
      size / 2,
      size / 2,
      size * 0.05,
      size / 2,
      size / 2,
      size * 0.5
    );

    g.addColorStop(0, `rgba(${c1},0.9)`);
    g.addColorStop(0.5, `rgba(${c2},0.5)`);
    g.addColorStop(1, "rgba(0,0,0,0)");

    ctx.fillStyle = g;
    ctx.fillRect(0, 0, size, size);

    return new THREE.CanvasTexture(c);
  }

  const glow = new THREE.Sprite(
    new THREE.SpriteMaterial({
      map: makeGlow(),
      transparent: true,
      depthWrite: false
    })
  );
  glow.scale.set(500, 500, 1);
  scene.add(glow);

  function ringTexture(size = 768) {
    const c = document.createElement("canvas");
    c.width = c.height = size;
    const ctx = c.getContext("2d");

    ctx.translate(size / 2, size / 2);

    const inner = size * 0.34;
    const outer = size * 0.49;

    const g = ctx.createRadialGradient(0, 0, inner * 0.3, 0, 0, outer);
    g.addColorStop(0, "rgba(255,255,200,1)");
    g.addColorStop(0.3, "rgba(255,160,60,9)");
    g.addColorStop(0.65, "rgba(255,80,0,0.9)");
    g.addColorStop(1, "rgba(0,0,0,0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(0, 0, outer, 0, Math.PI * 2);
    ctx.arc(0, 0, inner, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();

    return new THREE.CanvasTexture(c);
  }

  const ring1 = new THREE.Mesh(
    new THREE.RingGeometry(50, 100, 128),
    new THREE.MeshBasicMaterial({
      map: ringTexture(),
      transparent: true,
      side: THREE.DoubleSide
    })
  );

  const ring2 = new THREE.Mesh(
    new THREE.RingGeometry(85, 150, 128),
    new THREE.MeshBasicMaterial({
      map: ringTexture(),
      transparent: true,
      side: THREE.DoubleSide,
      opacity: 5
    })
  );

  ring1.rotation.x = ring2.rotation.x = Math.PI / 2;
  scene.add(ring1);
  scene.add(ring2);

  const WORDS = [];
  const baseWords = [
    "üíñ Mi bebe","üò† Mi enojona","üåé Mi mundo","‚ú® Brillas","‚ù§Ô∏è Te amo",
    "üåå Te adoro","üëë Mi reina","üå† Estrella","üí´ Mi cielo","üî• Siempre t√∫",
    "üé∂ Tu risa","ü¶ã Libertad","üíé Eres todo","üôè Gracias","üíï Cari√±o",
    "üåπ Amor eterno","ü§ó Abrazos","üå∏ H. ABIGAIL","üòçHELEN A.","üåà Alegr√≠a","üåü A tu lado",
    "üß∏ AMOR MIO","üéÅ Mi raz√≥n","üåô Mi destino","üíå Recuerdos","üïäÔ∏è Mi paz",
    "ü™ê Mi universo","üåä Mi calma","üí° Mi luz","üçí Dulzura","ü•∞ Mi vida",
    "üéá Felicidad","üåª Alegr√≠a","ü§¨ Mi toxica","üíú So√±adora","üåü Sue√±os",
    "‚ú® Magia","üéµ Suo favela","üî•CORAZON","‚≠ê Mi estrella","üå¥ Mi para√≠so",
    "üåÑ Amanecer","üåÉ Mi rabiosa","üéâ Mi tranquilidad","üí´ Inspiraci√≥n",
    "üå∑ Siempre juntos","üéÄ Mi ternura","üçÄ Mi fortuna","ü™û Mi reflejo"
  ];

  for (let i = 0; i < 6; i++) {
    WORDS.push(...baseWords);
  }

  function makeTextTexture(text, color) {
    const c = document.createElement("canvas");
    c.width = 512;
    c.height = 128;
    const ctx = c.getContext("2d");

    ctx.clearRect(0, 0, c.width, c.height);
    ctx.font = "bold 60px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#fff";
    ctx.shadowColor = color;
    ctx.shadowBlur = 30;
    ctx.fillText(text, c.width / 2, c.height / 2);

    return new THREE.CanvasTexture(c);
  }

  const COLORS = [
    "#ff66ff","#66ccff","#ffd36b","#ff9966","#8df59a",
    "#ffa0f8","#c6a7ff","#ff4444","#44ff99","#99ccff"
  ];

  const textGroup = new THREE.Group();
  scene.add(textGroup);

  for (let i = 0; i < WORDS.length; i++) {
    const tex = makeTextTexture(WORDS[i], COLORS[i % COLORS.length]);
    const mat = new THREE.SpriteMaterial({
      map: tex,
      transparent: true
    });
    const spr = new THREE.Sprite(mat);

    spr.scale.set(50, 16, 1);

    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    const radius = 150 + 120 * Math.random();

    spr.position.set(
      radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );

    spr.userData = {
      phi,
      theta,
      radius,
      speed: 0.001 + 0.001 * Math.random()
    };

    textGroup.add(spr);
  }

  let dragging = false;
  let lastX = 0;
  let lastY = 0;

  function onDown(e) {
    dragging = true;
    const p = e.touches ? e.touches[0] : e;
    lastX = p.clientX;
    lastY = p.clientY;
  }

  function onMove(e) {
    if (!dragging) return;
    const p = e.touches ? e.touches[0] : e;

    const dx = (p.clientX - lastX) / innerWidth;
    const dy = (p.clientY - lastY) / innerHeight;

    rotY -= 3 * dx;
    rotX = Math.max(-1.2, Math.min(1.2, rotX - 2.2 * dy));

    lastX = p.clientX;
    lastY = p.clientY;
  }

  function onUp() {
    dragging = false;
  }

  addEventListener("mousedown", onDown);
  addEventListener("mousemove", onMove);
  addEventListener("mouseup", onUp);

  addEventListener("touchstart", onDown, { passive: true });
  addEventListener("touchmove", onMove, { passive: true });
  addEventListener("touchend", onUp, { passive: true });

  addEventListener(
    "wheel",
    e => {
      targetDist += 0.25 * e.deltaY;
      targetDist = Math.max(160, Math.min(600, targetDist));
    },
    { passive: true }
  );

  let pinch = 0;

  addEventListener(
    "touchmove",
    e => {
      if (e.touches && e.touches.length === 2) {
        e.preventDefault();

        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);

        if (pinch) {
          targetDist += 0.5 * (pinch - dist);
          targetDist = Math.max(160, Math.min(600, targetDist));
        }
        pinch = dist;
      }
    },
    { passive: false }
  );

  addEventListener(
    "touchend",
    () => {
      pinch = 0;
    },
    { passive: true }
  );

  let t = 0;

  function tick() {
    requestAnimationFrame(tick);

    t += 0.01;

    ring1.rotation.z += 0.002;
    ring2.rotation.z -= 0.0015;

    glow.scale.set(
      500 * (1 + 0.03 * Math.sin(0.4 * t)),
      500 * (1 + 0.03 * Math.sin(0.4 * t)),
      1
    );

    const s = 1 + 0.05 * Math.sin(3 * t);
    core.scale.set(s, s, s);

    textGroup.children.forEach(spr => {
      spr.material.opacity = 0.8 + 0.2 * Math.sin(2 * t);
      spr.userData.theta += spr.userData.speed;

      spr.position.x =
        spr.userData.radius *
        Math.sin(spr.userData.phi) *
        Math.cos(spr.userData.theta);

      spr.position.z =
        spr.userData.radius *
        Math.sin(spr.userData.phi) *
        Math.sin(spr.userData.theta);
    });

    currentDist += 0.06 * (targetDist - currentDist);

    const cx = Math.cos(rotX);
    const sx = Math.sin(rotX);
    const cy = Math.cos(rotY);
    const sy = Math.sin(rotY);

    camera.position.set(
      currentDist * sy * cx,
      currentDist * sx,
      currentDist * cy * cx
    );

    camera.lookAt(0, 0, 0);
    renderer.render(scene, camera);
  }

  tick();
blackholeBtn.addEventListener("click", () => {
  window.location.href = "albun_2026/principal.html";
});

</script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"fbf0b14aa0bb4a91a94f9d8e67c54c24","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>